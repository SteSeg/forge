import os
from pathlib import Path
from ase.io import write
from forge.core.database import DatabaseManager
from forge.workflows.helpers import determine_kpoint_grid
from forge.workflows.profiles import load_profile
from datetime import datetime


def is_job_already_pending(db_manager: DatabaseManager, structure_id: int, profile_name: str) -> bool:
    """Check metadata to see if a pending job for 'profile_name' is already marked."""
    metadata = db_manager.get_structure_metadata(structure_id)
    jobs_meta = metadata.get('jobs', {})
    info = jobs_meta.get(profile_name, {})
    return info.get('status') == 'pending'

def mark_job_pending(db_manager: DatabaseManager, structure_id: int, profile_name: str):
    """Mark a structure as having a pending job in the metadata for a given HPC profile."""
    metadata = db_manager.get_structure_metadata(structure_id)
    jobs_meta = metadata.get('jobs', {})
    jobs_meta[profile_name] = {
    "status": "pending",
    "timestamp": datetime.now().isoformat()
    }
    metadata['jobs'] = jobs_meta
    db_manager.update_structure_metadata(structure_id, metadata)

def write_incar(incar_dict, filepath):
    """Write INCAR from a dictionary of tags."""
    with open(filepath, 'w') as f:
        for key, value in incar_dict.items():
            f.write(f"{key} = {value}\n")

def write_potcar(symbols, potcar_map, potcar_dir, output_path):
    """
    Write or concatenate POTCAR files in a specific order.
    'symbols' is a sorted list of unique chemical symbols.
    'potcar_map' is element -> potcar label (i.e. 'V': 'V_pv', etc.).
    'potcar_dir' is typically read from an environment variable like VASP_PP_PATH
    where each POTCAR file is located.
    """
    with open(output_path, 'wb') as out_potcar:
        for elem in symbols:
            pot_label = potcar_map.get(elem)
            if not pot_label:
                raise ValueError(f"No POTCAR mapping found for element {elem}")
            potcar_path = os.path.join(potcar_dir, pot_label, "POTCAR")
            if not os.path.exists(potcar_path):
                raise FileNotFoundError(f"POTCAR not found for {pot_label} at {potcar_path}")
            with open(potcar_path, 'rb') as pfile:
                out_potcar.write(pfile.read())

def write_kpoints(filepath, kpoints, gamma_centered):
    """
    Write a basic KPOINTS file.
    kpoints: (kx, ky, kz) tuple
    gamma_centered: boolean
    """
    with open(filepath, 'w') as f:
        f.write("KPOINTS generated by db_to_vasp\n")
        f.write("0\n")  # Automatically generated k-points
        f.write("Monkhorst\n" if not gamma_centered else "Gamma\n")
        f.write(f"{kpoints[0]} {kpoints[1]} {kpoints[2]}\n")
        f.write("0 0 0\n")

def create_slurm_script(hpc_profile, job_name, output_dir):
    """
    Build the Slurm script from HPC profile JSON/dict structure.
    Example HPC profile structure:
    {
        "slurm_directives": {
            "job-name": "vasp",
            "nodes": 1,
            "time": "01:00:00",
            "partition": "standard"
        },
        "module_load": "module load vasp-tpc/6.4.2-cpu",
        "run_command": "srun -n ${TOTAL_CORES} -c 4 vasp_std",
        "tasks_per_node": 64
    }
    """
    slurm_directives = hpc_profile.get("slurm_directives", {})
    module_load = hpc_profile.get("module_load", "")
    run_cmd = hpc_profile.get("run_command", "")
    tasks_per_node = hpc_profile.get("tasks_per_node", 1)
    # Build the #SBATCH lines
    sbatch_lines = [
        "#!/bin/bash",
        f"#SBATCH --job-name={job_name}",
        f"#SBATCH --output={output_dir}/{job_name}.out",
        f"#SBATCH --error={output_dir}/{job_name}.err"
    ]
    for key, val in slurm_directives.items():
        if key == "job-name":
            # already handled above
            continue
        sbatch_lines.append(f"#SBATCH --{key}={val}")
    script_lines = sbatch_lines + [
        "",
        module_load,
        "",
        "# Calculate total cores based on tasks_per_node number of nodes"
    ]
    # For HPC, we might parse the number of nodes from slurm_directives
    # or default to 1 if it's not present
    node_str = slurm_directives.get("nodes", 1)
    try:
        num_nodes = int(node_str)
    except ValueError:
        num_nodes = 1
    total_cores = num_nodes * tasks_per_node
    # Insert run command
    if "${TOTAL_CORES}" in run_cmd:
        run_cmd = run_cmd.replace("${TOTAL_CORES}", str(total_cores))
    script_lines.append(f"cd {output_dir}")
    script_lines.append(run_cmd)
    return "\n".join(script_lines) + "\n"

def prepare_vasp_job(
    db_manager: DatabaseManager,
    structure_id: int,
    vasp_profile_path: str,
    hpc_profile_path: str,
    output_dir: str = None,
    auto_kpoints: bool = False
):
    """
    Main function to create a VASP job folder from a structure in the DB,
    using specified VASP profile (INCAR, POTCAR map, etc.) and HPC profile (Slurm).
    """
    # 1. Check if already pending
    hpc_profile_name = Path(hpc_profile_path).stem  # e.g. "Perlmutter-CPU"
    if is_job_already_pending(db_manager, structure_id, hpc_profile_name):
        print(f"Structure {structure_id} is already pending for {hpc_profile_name}. Skipping.")
        return
    # 2. Mark pending
    mark_job_pending(db_manager, structure_id, hpc_profile_name)
    # 3. Load profiles
    vasp_profile = load_profile(vasp_profile_path)  # from JSON
    hpc_profile = load_profile(hpc_profile_path)
    # 4. Fetch Atoms from DB
    atoms = db_manager.get_structure(structure_id)
    # 5. Create job dir
    if output_dir is None:
        output_dir = f"job_{structure_id}"
    os.makedirs(output_dir, exist_ok=True)
    # 6. Write POSCAR
    write(os.path.join(output_dir, "POSCAR"), atoms, format="vasp")
    # 7. Write INCAR
    incar_path = os.path.join(output_dir, "INCAR")
    write_incar(vasp_profile["incar"], incar_path)
    # 8. Determine KPOINTS
    # Use auto_kpoints with your existing function
    base_kpts = vasp_profile["kpoints"].get("base_kpts", [4,4,4])
    gamma_center = vasp_profile["kpoints"].get("gamma", True)
    kpts, gamma_flag = determine_kpoint_grid(
        atoms,
        auto_kpoints=auto_kpoints,
        base_kpts=tuple(base_kpts),
        gamma=gamma_center
    )
    kpoints_path = os.path.join(output_dir, "KPOINTS")
    write_kpoints(kpoints_path, kpts, gamma_flag)
    # 9. Write POTCAR (need VASP_PP_PATH)
    potcar_map = vasp_profile["potcars"]
    potcar_dir = os.environ.get("VASP_PP_PATH", "")  # or other fallback
    unique_species = sorted(set(atoms.get_chemical_symbols()))
    potcar_path = os.path.join(output_dir, "POTCAR")
    write_potcar(unique_species, potcar_map, potcar_dir, potcar_path)
    # 10. Create Slurm script
    slurm_script = create_slurm_script(hpc_profile, f"job_{structure_id}", output_dir)
    with open(os.path.join(output_dir, "submit.sh"), 'w') as f:
        f.write(slurm_script)
    print(f"Created VASP job for structure {structure_id} in {output_dir} using {hpc_profile_name}")
